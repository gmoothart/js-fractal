<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" media="all" href="960.css" />
    <style>
      body {
        background-color: #123;
      }
      .container_12 {
        background-color: white;
      }

      .crosshair{
        cursor: crosshair;
      }
    </style>
  </head>
  <body>
    <div class="container_12">
      <div class="grid_12">
        <h1>Fractal Viewer</h1>
        <fieldset>
          <legend>Mandelbrot</legend>
          <button id="mandelZoom">Zoom</button>
          <button id="mandelReset">Reset</button>
          <input id="mandelOverlay" type="checkbox" />
          <label for="mandelOverlay">Overlay Julia Set</label>
        </fieldset>
      </div>
      <div class="clear"></div>
      <div class="grid_11" style="height:600px;">
        <canvas id="c" width=800 height="600" style="position:absolute;z-index:0" ></canvas>
        <canvas id="overlayCanvas" width=800 height="600" style="position:absolute;z-index:1" ></canvas>
      </div>
      <div class="grid_1">
          <!-- Placeholder for fractal menu -->
      </div>
      <div class="clear"></div>
      <div>
        <span>Coordinates:</span>
        <span id="coordspan"></span>
      </div>
    </div>
      <script src="mandelbrot.js"></script>
      <script src="jquery-1.7.1.js"></script>
      <script>
          "use strict";
          var overlay = $('#overlayCanvas'),
              world = {
                  width: overlay.width(),
                  height: overlay.height(),
                  minR: -2.5,
                  maxR: 1.5,
                  minI: -1.5,
                  maxI: 1.5,
              },
              previewWorld = {
                  width: 120,
                  height: 90,
                  minR: -2.5,
                  maxR: 1.5,
                  minI: -1.5,
                  maxI: 1.5,
              },
              overlayCtx = overlay[0].getContext('2d'),
              isDragging = false,
              rectXStart, rectYStart,
              rectXEnd, rectYEnd,
              selectionEvents = {
                  'mousedown.selection': function(ev) {
                      isDragging = true;

                      rectXStart = ev.offsetX;
                      rectYStart = ev.offsetY;
                  },
                  'mouseup.selection mouseout.selection': function(ev) {
                      isDragging = false;
                  },
                  'mousemove.selection': function(ev) {
                      var startP,
                          currP = mandelbrot.xy_to_ri(ev.offsetX, ev.offsetY, world)

                      if (isDragging) {
                          startP = mandelbrot.xy_to_ri(rectXStart, rectYStart, world);
                          rectXEnd = ev.offsetX;

                          // constrain selection to canvas aspect ration
                          if (ev.offsetY > rectYStart) {
                            rectYEnd = rectYStart + 3*(Math.abs(rectXStart - ev.offsetX)) / 4;
                          }
                          else {
                            rectYEnd = rectYStart - 3*(Math.abs(rectXStart - ev.offsetX)) / 4;
                          }

                          overlayCtx.clearRect(0,0,world.width, world.height);
                          overlayCtx.strokeStyle = '#6699ff';
                          overlayCtx.beginPath();
                          overlayCtx.moveTo(rectXStart, rectYStart);
                          overlayCtx.lineTo(rectXStart, rectYEnd);
                          overlayCtx.lineTo(rectXEnd, rectYEnd);
                          overlayCtx.lineTo(rectXEnd, rectYStart);
                          overlayCtx.lineTo(rectXStart, rectYStart);
                          overlayCtx.stroke();

                          // show selection region
                          $('#coordspan').text('(' + startP.r + ', ' + startP.i + ') to (' + currP.r + ', ' + currP.i + ')');

                      }
                      else {
                          // show current point
                          $('#coordspan').text('(' + currP.r + ', ' + currP.i + ')');
                      }
                  }
              },
              juliaOverlayEvents = {
                  'mousemove.juliaOverlay': function(ev) {

                      var ctx,
                          imgData,
                          startP = mandelbrot.xy_to_ri(ev.offsetX, ev.offsetY, world)


                      console.log('draw overlay at (' + startP.r + ',' + startP.i + ')');

                      ctx = $('#c')[0].getContext('2d'),
                      imgData = ctx.createImageData(previewWorld.width, previewWorld.height);

                      // show julia preview
                      mandelbrot.computeJulia(previewWorld, startP.r, startP.i,
                        function(x,y,rgbArr) { drawToImageData(imgData.data,previewWorld.width,x,y,rgbArr); },
                        invertColors(setColorGrayscale));

                      ctx.putImageData(imgData, 0, 0);
                  },
                  'click.juliaOverlay': function(ev) {
                      // switch to Julia set
                      Julia.draw(ev.offsetX, ev.offsetY);

                  }
              }

          overlay.on(selectionEvents);
          $('#mandelZoom').on('click', function(ev) {

              var ctx,
                  imgData;

              updateWorld(rectXStart, rectYStart, rectXEnd, rectYEnd);

              ctx = $('#c')[0].getContext('2d'),
              imgData = ctx.createImageData(world.width,world.height);


              mandelbrot.compute(world, 
                function(x,y,rgbArr) { drawToImageData(imgData.data,world.width,x,y,rgbArr); },
                setColorGrayscale);

              ctx.putImageData(imgData, 0, 0);

              // clear selection box
              overlayCtx.clearRect(0,0,world.width,world.height);
          });

          $('#mandelReset').on('click', function(ev) {
              var ctx,
                  imgData;

              resetWorld();

              ctx = $('#c')[0].getContext('2d'),
              imgData = ctx.createImageData(world.width,world.height);


              mandelbrot.compute(world, 
                function(x,y,rgbArr) { drawToImageData(imgData.data,world.width,x,y,rgbArr); },
                setColorGrayscale);

              ctx.putImageData(imgData, 0, 0);

              // clear selection box
              overlayCtx.clearRect(0,0,world.width,world.height);
          });

          $('#mandelOverlay').on('change', function(ev) {
              //
              // Toggle between rectangle-selection zoom and julia ovelay mode
              //
              overlayCtx.clearRect(0,0,world.width,world.height);
              overlay.toggleClass('crosshair');

              if ($(ev.currentTarget).is(':checked')) {
                  overlay.off('.selection');
                  overlay.on(juliaOverlayEvents);
              }
              else {
                  overlay.on(selectionEvents);
                  overlay.off('.juliaOveraly');
              }
          });

        function updateWorld(newx1, newy1, newx2, newy2) {
            var p1 = mandelbrot.xy_to_ri(newx1, newy1, world),
                p2 = mandelbrot.xy_to_ri(newx2, newy2, world)

            if (p1.r > p2.r) {
                world.maxR = p1.r;
                world.minR = p2.r;
            }
            else {
                world.maxR = p2.r;
                world.minR = p1.r;
            }

            if (p1.i > p2.i) {
                world.minI = p2.i;
                world.maxI = p1.i;
            }
            else {
                world.minI = p1.i;
                world.maxI = p2.i;
            }
        }

        function resetWorld() {
            world.minR = -2.5;
            world.maxR = 1.5;
            world.minI = -1.5;
            world.maxI = 1.5;
        }

        function setColorGrayscale(iter, maxIter) {
            // normalize to a 0..255 range
            var norm = Math.floor(255 * iter/maxIter);

            // simple, just scale smoothly from white to black
            return [norm, norm, norm, 255];
        }

        function invertColors(colorFn) {
            return function(iter,maxIter) {
                var a = colorFn(iter,maxIter);

                a[0] = 255-a[0];
                a[1] = 255-a[1];
                a[2] = 255-a[2];

                return a;
            };
        }

        function drawToImageData(pixelArr, width, x, y, rgbArr) {

              var pos = (y*width + x) * 4;

              pixelArr[pos + 0] = rgbArr[0]; // R
              pixelArr[pos + 1] = rgbArr[1]; // G
              pixelArr[pos + 2] = rgbArr[2]; // B
              pixelArr[pos + 3] = rgbArr[3]; // Alpha
        }


        // draw the full set
        var ctx = $('#c')[0].getContext('2d'),
            imgData = ctx.createImageData(world.width,world.height);

        mandelbrot.compute(world, 
          function(x,y,rgbArr) { drawToImageData(imgData.data, world.width, x, y, rgbArr); },
          setColorGrayscale);

        ctx.putImageData(imgData, 0, 0);

      </script>
  </body>
</html>
